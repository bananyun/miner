<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Копатель онлайн</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #202020;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #f1f1f1;
    }
    #overlay {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(0, 0, 0, 0.45);
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.4);
      backdrop-filter: blur(2px);
      width: fit-content;
    }
    #buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      background: #2b7a2b;
      border: none;
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }
    button:hover { background: #359735; }
    button:active { transform: translateY(1px); }
    #hotbar {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      display: inline-flex;
      gap: 6px;
      align-items: center;
      z-index: 9999;
      width: fit-content;
      padding: 10px 12px 8px;
      background: linear-gradient(180deg, rgba(20,20,20,0.9), rgba(10,10,10,0.8));
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.55);
    }
    #hotbar::before {
      content: "";
      position: absolute;
      left: 10px;
      right: 10px;
      top: 6px;
      height: 6px;
      background: rgba(255,255,255,0.12);
      border-radius: 3px;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.4);
      pointer-events: none;
    }
    .slot {
      width: 46px;
      height: 46px;
      border-radius: 4px;
      display: grid;
      place-items: center;
      border: 2px solid rgba(255,255,255,0.08);
      color: #111;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s, border-color 0.1s, box-shadow 0.1s;
      position: relative;
      background: linear-gradient(180deg, #2b2b2b, #1b1b1b);
      box-shadow:
        inset 0 1px 1px rgba(255,255,255,0.08),
        inset 0 -1px 2px rgba(0,0,0,0.4),
        0 1px 2px rgba(0,0,0,0.6);
    }
    .slot::after {
      content: "";
      position: absolute;
      inset: 4px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.05), rgba(0,0,0,0.3));
      border-radius: 2px;
      pointer-events: none;
    }
    .slot.active {
      border-color: #e0e6ff;
      box-shadow:
        0 0 0 2px rgba(180,200,255,0.35),
        0 0 10px 2px rgba(120,160,255,0.35),
        inset 0 1px 1px rgba(255,255,255,0.15);
      transform: translateY(-1px);
    }
    .slot .num {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 11px;
      color: #dfe4f0;
      text-shadow: 0 1px 2px rgba(0,0,0,0.9);
      font-weight: 600;
    }
    .slot .count {
      position: absolute;
      right: 4px;
      bottom: 2px;
      font-size: 13px;
      color: #f8f8f8;
      text-shadow: 0 1px 3px rgba(0,0,0,0.9);
      font-weight: 700;
    }
    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 18px;
      height: 18px;
      margin-left: -9px;
      margin-top: -9px;
      pointer-events: none;
      z-index: 5;
    }
    #crosshair:before, #crosshair:after {
      content: '';
      position: absolute;
      background: #fff;
    }
    #crosshair:before {
      left: 8px;
      top: 0;
      width: 2px;
      height: 18px;
    }
    #crosshair:after {
      left: 0;
      top: 8px;
      width: 18px;
      height: 2px;
    }
    #hint {
      font-size: 13px;
      color: #dcdcdc;
      line-height: 1.5;
    }
    #log {
      position: absolute;
      right: 10px;
      bottom: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      max-width: 260px;
    }
    #progress {
      position: absolute;
      left: 50%;
      top: 52%;
      width: 120px;
      height: 10px;
      margin-left: -60px;
      border: 1px solid rgba(255,255,255,0.5);
      border-radius: 6px;
      overflow: hidden;
      background: rgba(0,0,0,0.4);
      box-shadow: 0 0 8px rgba(0,0,0,0.6);
      display: none;
      z-index: 6;
    }
    #progress .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #58d957, #2ea72d);
      transition: width 0.05s;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="buttons">
      <button id="save">Save</button>
      <button id="load">Load</button>
    </div>
    <div id="hint">
      ЛКМ — сломать, ПКМ — поставить блок.<br>
      Клик по экрану включает захват мыши.
    </div>
  </div>
  <div id="hotbar"></div>
  <div id="crosshair"></div>
  <div id="progress"><div class="bar"></div></div>
  <div id="log">Готово</div>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x7ec0ee);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.rotation.order = 'YXZ';
    const ambient = new THREE.HemisphereLight(0xffffff, 0x556677, 0.7);
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(30, 60, 20);
    sun.castShadow = false;
    scene.add(ambient, sun);

    const WORLD_SIZE = 64;
    const WORLD_HEIGHT = 48;
    const world = new Map();
    const meshes = new Map();
    const drops = [];

    const blockTypes = [
      { name: 'Grass', color: 0x7acb4d },
      { name: 'Dirt', color: 0x8b5a2b },
      { name: 'Stone', color: 0x9fa3a6 },
      { name: 'Wood', color: 0xc18f5a },
      { name: 'Sand', color: 0xe9ddad },
      { name: 'Ore', color: 0x8bc5ff },
    ];
    const materials = blockTypes.map(t => new THREE.MeshStandardMaterial({ color: t.color, flatShading: true }));

    const HOTBAR_SLOTS = 9;
    const inventory = Array.from({ length: HOTBAR_SLOTS }, () => ({ type: null, count: 0 }));
    let selectedSlot = 0;

    function seedInventory() {
      const starter = [0, 1, 2, 3, 4];
      starter.forEach((type, idx) => {
        inventory[idx].type = type;
        inventory[idx].count = 16;
      });
    }
    seedInventory();

    const hotbar = document.getElementById('hotbar');
    for (let i = 0; i < HOTBAR_SLOTS; i++) {
      const slot = document.createElement('div');
      slot.className = 'slot' + (i === selectedSlot ? ' active' : '');
      slot.dataset.slot = i;
      const num = document.createElement('div');
      num.className = 'num';
      num.textContent = i + 1;
      const count = document.createElement('div');
      count.className = 'count';
      slot.append(num, count);
      slot.onclick = () => setSelectedSlot(i);
      hotbar.appendChild(slot);
    }

    function renderHotbar() {
      [...hotbar.children].forEach((el, idx) => {
        const slot = inventory[idx];
        el.classList.toggle('active', idx === selectedSlot);
        if (slot.type !== null && slot.count > 0) {
          el.style.background = '#' + blockTypes[slot.type].color.toString(16).padStart(6, '0');
          el.title = `${idx + 1}: ${blockTypes[slot.type].name}`;
          el.querySelector('.count').textContent = slot.count;
        } else {
          el.style.background = '#303030';
          el.title = `${idx + 1}: Пусто`;
          el.querySelector('.count').textContent = '';
          slot.type = null;
          slot.count = 0;
        }
      });
    }

    function setSelectedSlot(idx) {
      selectedSlot = idx;
      renderHotbar();
    }
    renderHotbar();

    const dropGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
    const outlineGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1));
    const outlineMat = new THREE.LineBasicMaterial({ color: 0xffffff });
    const outlineMesh = new THREE.LineSegments(outlineGeo, outlineMat);
    outlineMesh.visible = false;
    scene.add(outlineMesh);
    function findSlotWithType(type) {
      return inventory.findIndex(s => s.type === type && s.count > 0);
    }
    function findEmptySlot() {
      return inventory.findIndex(s => s.type === null || s.count === 0);
    }
    function addToInventory(type, count = 1) {
      let idx = findSlotWithType(type);
      if (idx === -1) idx = findEmptySlot();
      if (idx === -1) return false;
      const slot = inventory[idx];
      slot.type = type;
      slot.count = (slot.count || 0) + count;
      renderHotbar();
      return true;
    }
    function selectedBlockType() {
      const slot = inventory[selectedSlot];
      if (!slot || slot.count <= 0 || slot.type === null) return null;
      return slot.type;
    }
    function consumeSelectedBlock() {
      const slot = inventory[selectedSlot];
      if (!slot || slot.count <= 0) return false;
      slot.count -= 1;
      if (slot.count <= 0) {
        slot.count = 0;
        slot.type = null;
      }
      renderHotbar();
      return true;
    }

    function serializeInventory() {
      return inventory.map(s => ({ type: s.type, count: s.count }));
    }
    function deserializeInventory(data) {
      inventory.forEach((slot, idx) => {
        const source = data?.[idx];
        slot.type = source?.type ?? null;
        slot.count = source?.count ?? 0;
      });
      renderHotbar();
    }

    const logEl = document.getElementById('log');
    const log = (msg) => logEl.textContent = msg;
    const progressEl = document.getElementById('progress');
    const progressBar = progressEl.querySelector('.bar');
    let mouseLeftDown = false;
    let currentHit = null;
    const mining = { target: null, progress: 0, required: 0, type: null };

    function keyFor(x, y, z) { return `${x},${y},${z}`; }
    function getBlock(x, y, z) { return world.get(keyFor(x, y, z)); }
    function isSolid(x, y, z) { return world.has(keyFor(x, y, z)); }

    const faceDefs = [
      { dir: [1, 0, 0],  corners: [[0.5, -0.5, -0.5],[0.5, 0.5, -0.5],[0.5, 0.5, 0.5],[0.5, -0.5, 0.5]] },
      { dir: [-1, 0, 0], corners: [[-0.5, -0.5, 0.5],[-0.5, 0.5, 0.5],[-0.5, 0.5, -0.5],[-0.5, -0.5, -0.5]] },
      { dir: [0, 1, 0],  corners: [[-0.5, 0.5, 0.5],[0.5, 0.5, 0.5],[0.5, 0.5, -0.5],[-0.5, 0.5, -0.5]] },
      { dir: [0, -1, 0], corners: [[-0.5, -0.5, -0.5],[0.5, -0.5, -0.5],[0.5, -0.5, 0.5],[-0.5, -0.5, 0.5]] },
      { dir: [0, 0, 1],  corners: [[0.5, -0.5, 0.5],[0.5, 0.5, 0.5],[-0.5, 0.5, 0.5],[-0.5, -0.5, 0.5]] },
      { dir: [0, 0, -1], corners: [[-0.5, -0.5, -0.5],[-0.5, 0.5, -0.5],[0.5, 0.5, -0.5],[0.5, -0.5, -0.5]] },
    ];

    function buildGeometryForBlock(x, y, z) {
      const positions = [];
      const normals = [];
      const indices = [];
      let faceCount = 0;
      faceDefs.forEach(({ dir, corners }) => {
        const nx = x + dir[0];
        const ny = y + dir[1];
        const nz = z + dir[2];
        if (isSolid(nx, ny, nz)) return;
        const baseIndex = positions.length / 3;
        corners.forEach(c => positions.push(c[0] + x, c[1] + y, c[2] + z));
        for (let i = 0; i < 4; i++) normals.push(...dir);
        indices.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex, baseIndex + 2, baseIndex + 3);
        faceCount++;
      });
      if (!positions.length) return null;
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geo.setIndex(indices);
      geo.computeBoundingSphere();
      return geo;
    }

    function removeBlockMesh(x, y, z) {
      const k = keyFor(x, y, z);
      const mesh = meshes.get(k);
      if (mesh) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        meshes.delete(k);
      }
    }

    function updateBlockMesh(x, y, z) {
      removeBlockMesh(x, y, z);
      if (!isSolid(x, y, z)) return;
      const geo = buildGeometryForBlock(x, y, z);
      if (!geo) return;
      const type = getBlock(x, y, z);
      const mesh = new THREE.Mesh(geo, materials[type]);
      mesh.userData.block = { x, y, z };
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      scene.add(mesh);
      meshes.set(keyFor(x, y, z), mesh);
    }

    function refreshNeighbors(x, y, z) {
      for (const [dx, dy, dz] of [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]]) {
        updateBlockMesh(x + dx, y + dy, z + dz);
      }
    }

    function addBlock(x, y, z, type) {
      if (y < 0 || y >= WORLD_HEIGHT) return false;
      const k = keyFor(x, y, z);
      if (world.has(k)) return false;
      world.set(k, type);
      updateBlockMesh(x, y, z);
      refreshNeighbors(x, y, z);
      return true;
    }

    function removeBlock(x, y, z) {
      const k = keyFor(x, y, z);
      if (!world.has(k)) return null;
      const type = world.get(k);
      world.delete(k);
      removeBlockMesh(x, y, z);
      refreshNeighbors(x, y, z);
      return type;
    }

    function blockIntersectsPlayer(x, y, z) {
      const blockMin = new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5);
      const blockMax = new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5);
      const playerMin = new THREE.Vector3(
        player.position.x - bounds.xz,
        player.position.y - bounds.y,
        player.position.z - bounds.xz
      );
      const playerMax = new THREE.Vector3(
        player.position.x + bounds.xz,
        player.position.y + bounds.y,
        player.position.z + bounds.xz
      );
      if (playerMax.x <= blockMin.x || playerMin.x >= blockMax.x) return false;
      if (playerMax.y <= blockMin.y || playerMin.y >= blockMax.y) return false;
      if (playerMax.z <= blockMin.z || playerMin.z >= blockMax.z) return false;
      return true;
    }

    function spawnDrop(type, position) {
      const mesh = new THREE.Mesh(dropGeometry, materials[type]);
      const jitter = 0.15;
      mesh.position.copy(position).add(new THREE.Vector3(
        (Math.random() * 2 - 1) * jitter,
        0.6,
        (Math.random() * 2 - 1) * jitter,
      ));
      scene.add(mesh);
      drops.push({
        mesh,
        type,
        velocity: new THREE.Vector3((Math.random() * 0.4 - 0.2), 0.4, (Math.random() * 0.4 - 0.2)),
      });
    }

    function hash2(x, z) {
      const s = Math.sin(x * 374761393 + z * 668265263) * 43758.5453;
      return s - Math.floor(s);
    }
    function fade(t) { return t * t * (3 - 2 * t); }
    function valueNoise(x, z) {
      const xi = Math.floor(x);
      const zi = Math.floor(z);
      const xf = x - xi;
      const zf = z - zi;
      const v00 = hash2(xi, zi);
      const v10 = hash2(xi + 1, zi);
      const v01 = hash2(xi, zi + 1);
      const v11 = hash2(xi + 1, zi + 1);
      const fx = fade(xf);
      const fz = fade(zf);
      const i1 = THREE.MathUtils.lerp(v00, v10, fx);
      const i2 = THREE.MathUtils.lerp(v01, v11, fx);
      return THREE.MathUtils.lerp(i1, i2, fz) * 2 - 1;
    }
    function fbm(x, z) {
      let total = 0;
      let amp = 0.8;
      let freq = 0.04;
      for (let i = 0; i < 5; i++) {
        total += amp * valueNoise(x * freq, z * freq);
        freq *= 2;
        amp *= 0.55;
      }
      return total;
    }

    function blurHeight(heights, size) {
      const out = new Array(size * size).fill(0);
      for (let x = 0; x < size; x++) {
        for (let z = 0; z < size; z++) {
          let sum = 0;
          let count = 0;
          for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
              const nx = x + dx;
              const nz = z + dz;
              if (nx < 0 || nz < 0 || nx >= size || nz >= size) continue;
              sum += heights[nx * size + nz];
              count++;
            }
          }
          out[x * size + z] = sum / count;
        }
      }
      return out;
    }

    function clampSlope(heights, size, maxDelta = 2, iterations = 3) {
      for (let it = 0; it < iterations; it++) {
        let changed = false;
        for (let x = 0; x < size; x++) {
          for (let z = 0; z < size; z++) {
            const idx = x * size + z;
            const h = heights[idx];
            for (const [dx, dz] of [[1,0],[-1,0],[0,1],[0,-1]]) {
              const nx = x + dx, nz = z + dz;
              if (nx < 0 || nz < 0 || nx >= size || nz >= size) continue;
              const nIdx = nx * size + nz;
              if (heights[nIdx] > h + maxDelta) {
                heights[nIdx] = h + maxDelta;
                changed = true;
              }
            }
          }
        }
        if (!changed) break;
      }
    }

    function generateWorld() {
      const half = Math.floor(WORLD_SIZE / 2);
      const size = half * 2 + 1;
      let heights = new Array(size * size).fill(0);
      for (let x = -half; x <= half; x++) {
        for (let z = -half; z <= half; z++) {
          const h = 12 + fbm(x, z) * 8;
          heights[(x + half) * size + (z + half)] = h;
        }
      }
      for (let i = 0; i < 3; i++) heights = blurHeight(heights, size);
      clampSlope(heights, size, 2, 4);
      for (let i = 0; i < heights.length; i++) heights[i] = Math.round(heights[i]);

      for (let x = -half; x <= half; x++) {
        for (let z = -half; z <= half; z++) {
          const idx = (x + half) * size + (z + half);
          const height = heights[idx];
          const dirtDepth = 2 + Math.floor((hash2(x, z) * 100) % 3); // 2-4 слоёв
          for (let y = 0; y <= height; y++) {
            let type = 2; // stone
            if (y === height) type = 0; // grass
            else if (y >= height - dirtDepth) type = 1; // dirt
            else if (hash2(x * 3 + y * 11, z * 5) > 0.97) type = 5; // ore
            addBlock(x, y, z, type);
          }
          if (hash2(x * 13, z * 17) > 0.985) {
            const trunk = 3 + Math.floor(hash2(x * 19, z * 23) * 3);
            const base = height + 1;
            for (let t = 0; t < trunk; t++) addBlock(x, base + t, z, 3);
            addBlock(x, base + trunk, z, 0);
          }
        }
      }
    }

    const player = {
      position: new THREE.Vector3(0, 24, 0),
      velocity: new THREE.Vector3(),
      yaw: 0,
      pitch: 0,
      onGround: false,
    };
    const speed = { walk: 8.0, run: 11.5, jump: 8.0, gravity: 22, friction: 10 };
    const bounds = { xz: 0.35, y: 0.9 };
    const EYE_HEIGHT = 0.7; // центр -> глаза ~1.6 м
    const keys = {};

    const pointerLockElement = renderer.domElement;
    pointerLockElement.addEventListener('click', () => {
      pointerLockElement.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === pointerLockElement) {
        log('Управление активировано. WASD/Space/Shift + мышь.');
      } else {
        mouseLeftDown = false;
        resetMining();
        log('Кликните по экрану для захвата мыши.');
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement !== pointerLockElement) return;
      const sensitivity = 0.0025;
      player.yaw -= e.movementX * sensitivity;
      player.pitch -= e.movementY * sensitivity;
      player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
    });

    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (/Digit[1-9]/.test(e.code)) {
        const idx = Number(e.code.slice(-1)) - 1;
        if (idx < HOTBAR_SLOTS) setSelectedSlot(idx);
      }
    });
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    const raycaster = new THREE.Raycaster();
    raycaster.far = 6;
    const mouse = new THREE.Vector2(0, 0);
    const breakTimes = { 0: 2, 1: 2, 4: 2, 2: 10, 3: 4, 5: 12 };

    function computeHit() {
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects([...meshes.values()], false);
      return hits.length ? hits[0] : null;
    }

    function updateRaycast() {
      currentHit = computeHit();
      if (currentHit) {
        const { x, y, z } = currentHit.object.userData.block;
        outlineMesh.position.set(x, y, z);
        outlineMesh.visible = true;
      } else {
        outlineMesh.visible = false;
      }
    }

    function resetMining() {
      mining.target = null;
      mining.progress = 0;
      mining.required = 0;
      mining.type = null;
      progressEl.style.display = 'none';
      progressBar.style.width = '0%';
    }

    function updateMining(dt) {
      if (!mouseLeftDown || document.pointerLockElement !== pointerLockElement) {
        resetMining();
        return;
      }
      if (!currentHit) { resetMining(); return; }
      const { x, y, z } = currentHit.object.userData.block;
      const key = keyFor(x, y, z);
      const type = getBlock(x, y, z);
      if (type === undefined) { resetMining(); return; }
      if (mining.target !== key) {
        mining.target = key;
        mining.progress = 0;
        mining.type = type;
        mining.required = breakTimes[type] ?? 2;
      }
      progressEl.style.display = 'block';
      mining.progress += dt;
      const pct = Math.min(1, mining.progress / mining.required);
      progressBar.style.width = `${pct * 100}%`;
      if (mining.progress >= mining.required) {
        const removedType = removeBlock(x, y, z);
        if (removedType !== null) {
          spawnDrop(removedType, new THREE.Vector3(x, y, z));
        }
        resetMining();
      }
    }

    window.addEventListener('mousedown', (e) => {
      if (document.pointerLockElement !== pointerLockElement) return;
      if (e.button === 0) {
        mouseLeftDown = true;
      } else if (e.button === 2) {
        updateRaycast();
        if (!currentHit) return;
        const { x, y, z } = currentHit.object.userData.block;
        const n = currentHit.face?.normal ?? new THREE.Vector3();
        const nx = x + n.x;
        const ny = y + n.y;
        const nz = z + n.z;
        const type = selectedBlockType();
        if (type === null) { log('Нет блока в выбранном слоте.'); return; }
        if (blockIntersectsPlayer(nx, ny, nz)) {
          log('Нельзя поставить блок здесь.');
          return;
        }
        const placed = addBlock(nx, ny, nz, type);
        if (placed) consumeSelectedBlock();
      }
    });
    window.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        mouseLeftDown = false;
        resetMining();
      }
    });
    window.addEventListener('contextmenu', (e) => e.preventDefault());

    function physics(dt) {
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      const accel = new THREE.Vector3();
      const run = keys['ShiftLeft'] || keys['ShiftRight'];
      const currentSpeed = run ? speed.run : speed.walk;
      if (keys['KeyW']) accel.add(forward);
      if (keys['KeyS']) accel.sub(forward);
      if (keys['KeyA']) accel.sub(right);
      if (keys['KeyD']) accel.add(right);
      const airFactor = player.onGround ? 1 : 0.6;
      accel.normalize().multiplyScalar(currentSpeed * airFactor);
      player.velocity.x += accel.x * dt;
      player.velocity.z += accel.z * dt;

      player.velocity.y -= speed.gravity * dt;
      if (player.onGround && keys['Space']) {
        player.velocity.y = speed.jump;
        player.onGround = false;
      }

      applyFriction(dt);
      moveWithCollisions(dt);
    }

    function applyFriction(dt) {
      const friction = Math.max(0, 1 - speed.friction * dt);
      player.velocity.x *= friction;
      player.velocity.z *= friction;
    }

    function moveAxis(axis, amount) {
      const pos = player.position;
      pos[axis] += amount;
      const min = new THREE.Vector3(pos.x - bounds.xz, pos.y - bounds.y, pos.z - bounds.xz);
      const max = new THREE.Vector3(pos.x + bounds.xz, pos.y + bounds.y, pos.z + bounds.xz);
      const startX = Math.floor(min.x);
      const endX = Math.floor(max.x);
      const startY = Math.floor(min.y);
      const endY = Math.floor(max.y);
      const startZ = Math.floor(min.z);
      const endZ = Math.floor(max.z);
      for (let x = startX; x <= endX; x++) {
        for (let y = startY; y <= endY; y++) {
          for (let z = startZ; z <= endZ; z++) {
            if (!isSolid(x, y, z)) continue;
            const bxMin = x - 0.5, bxMax = x + 0.5;
            const byMin = y - 0.5, byMax = y + 0.5;
            const bzMin = z - 0.5, bzMax = z + 0.5;
            if (max.x <= bxMin || min.x >= bxMax || max.y <= byMin || min.y >= byMax || max.z <= bzMin || min.z >= bzMax) continue;
            if (amount > 0) pos[axis] = axis === 'y' ? byMin - bounds.y - 0.001 : (axis === 'x' ? bxMin - bounds.xz - 0.001 : bzMin - bounds.xz - 0.001);
            else pos[axis] = axis === 'y' ? byMax + bounds.y + 0.001 : (axis === 'x' ? bxMax + bounds.xz + 0.001 : bzMax + bounds.xz + 0.001);
            player.velocity[axis] = 0;
            if (axis === 'y' && amount < 0) player.onGround = true;
            return;
          }
        }
      }
    }

    function moveWithCollisions(dt) {
      player.onGround = false;
      moveAxis('y', player.velocity.y * dt);
      moveAxis('x', player.velocity.x * dt);
      moveAxis('z', player.velocity.z * dt);
    }

    function updateDrops(dt) {
      const removals = [];
      const maxSpeed = 8;
      const gravityDrop = 9.8;
      drops.forEach((drop, idx) => {
        drop.velocity.y -= gravityDrop * dt;
        drop.velocity.x *= Math.max(0, 1 - 6 * dt);
        drop.velocity.z *= Math.max(0, 1 - 6 * dt);
        const speedLen = drop.velocity.length();
        if (speedLen > maxSpeed) {
          drop.velocity.multiplyScalar(maxSpeed / speedLen);
        }
        drop.mesh.position.addScaledVector(drop.velocity, dt);

        const px = Math.floor(drop.mesh.position.x);
        const py = Math.floor(drop.mesh.position.y - 0.4);
        const pz = Math.floor(drop.mesh.position.z);
        if (isSolid(px, py, pz)) {
          drop.mesh.position.y = py + 1.0;
          drop.velocity.y *= -0.2;
        }
        if (drop.velocity.length() < 0.05) {
          drop.velocity.set(0, 0, 0);
        }

        const dist = drop.mesh.position.distanceTo(player.position);
        if (dist <= 1.5) {
          const lerpT = Math.min(0.5, dt * 5);
          drop.mesh.position.lerp(player.position, lerpT);
          if (dist <= 1.0 && addToInventory(drop.type, 1)) {
            scene.remove(drop.mesh);
            removals.push(idx);
            return;
          }
        }

        if (drop.mesh.position.y < -10) {
          scene.remove(drop.mesh);
          removals.push(idx);
        }
      });
      removals.sort((a, b) => b - a).forEach(i => drops.splice(i, 1));
    }

    function resizeRenderer() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resizeRenderer);
    resizeRenderer();

    function saveWorld() {
      const data = {
        world: [...world.entries()],
        inventory: serializeInventory(),
        selectedSlot,
        player: {
          pos: [player.position.x, player.position.y, player.position.z],
          yaw: player.yaw,
          pitch: player.pitch,
        },
      };
      localStorage.setItem('voxelWorld', JSON.stringify(data));
      log('Мир сохранён в localStorage.');
    }
    function loadWorld() {
      const data = localStorage.getItem('voxelWorld');
      if (!data) { log('Нет сохранений.'); return; }
      clearWorld();
      const parsed = JSON.parse(data);
      parsed.world?.forEach(([k, v]) => {
        const [x, y, z] = k.split(',').map(Number);
        world.set(k, v);
        updateBlockMesh(x, y, z);
      });
      world.forEach((_, key) => {
        const [x, y, z] = key.split(',').map(Number);
        refreshNeighbors(x, y, z);
      });
      const p = parsed.player;
      if (p?.pos) player.position.set(p.pos[0], p.pos[1], p.pos[2]);
      player.velocity.set(0, 0, 0);
      player.yaw = p?.yaw ?? 0;
      player.pitch = p?.pitch ?? 0;
      if (typeof parsed.selectedSlot === 'number') selectedSlot = parsed.selectedSlot;
      deserializeInventory(parsed.inventory);
      renderHotbar();
      log('Мир загружен.');
    }
    function clearWorld() {
      meshes.forEach(mesh => {
        scene.remove(mesh);
        mesh.geometry.dispose();
      });
      meshes.clear();
      world.clear();
      drops.forEach(d => scene.remove(d.mesh));
      drops.length = 0;
    }

    document.getElementById('save').onclick = saveWorld;
    document.getElementById('load').onclick = loadWorld;

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, clock.getDelta() || 1 / 60);
      physics(dt);
      camera.position.copy(player.position).add(new THREE.Vector3(0, EYE_HEIGHT, 0));
      camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
      updateRaycast();
      updateMining(dt);
      updateDrops(dt);
      renderer.render(scene, camera);
    }

    function init() {
      generateWorld();
      animate();
      log('Готово. Нажмите на экран для захвата.');
    }
    init();
  </script>
</body>
</html>
